sdk-gcc

## 2018/3/10

11点11分，将样例的输出直接输出。

## 2018/3/12

今天已经过去3天了。昨天将输入输出调试成功，顺利的提交了一个baseline_0.155。

今天，感觉有很多需要优化的地方，比如在读取数据方面，之前先将char * info的数据转化为string s类型，然后将string类型赋值给stringstream ss(s)，再将ss输入流读入到相应变量。但是发现这种方式，通过clock_t start,finish测试，速度要比sscanf函数慢一倍。于是将sscanf作为读取数据的函数。sscanf使用方式可以参考[http://www.cplusplus.com/reference/cstdio/sscanf/](http://www.cplusplus.com/reference/cstdio/sscanf/)这篇文章。

同样，文件中涉及到大量的时间处理格式，比如输入文件中的需要预测天数之间的间隔。需要将字符串的时间转换为整数，可以使用time_t类型来处理，详细的转换过程，可以参考[c/c++日期时间处理与字符串string转换](http://www.cnblogs.com/renjiashuo/p/6913668.html)这篇博客。

在读入train数据时，是可以先将vector的大小分配出来，这样避免后续总是扩展，移动而浪费时间。真是用了python，再用其他的好难受。

还有，实际上，train文件虚拟机ID以及创建时间的时分秒是不需要的，在处理时，将ID删除，将时分秒全部置换为0。

接下来，需要对input文件中的所有规格的虚拟机进行预测(注：有两种特殊情况)

- input文件中的有虚拟机，而train文件中没有出现，则对此类虚拟机预测为0,同时从最终的输出列表中删除。
- input文件中没有的虚拟机，而train文件中出现，此类不需要预测，因为题目要求：**测试用例输入的虚拟机规格通常只是历史数据的一部分,不是全部,参赛者只需要对输入的虚拟机规格进行预测即可,其他虚拟机规格无需考虑。**

接下来，对train文件的处理，因为已经将文件保存为vector<Train>的数据形式，而后面需要将每一种类型的虚拟机单独预测处理。

## 2018/3/13

昨天写的一个均值预测，加上FirstFit算法，在本地文件上测试，没有任何问题，但是一提交上去，就报错"answer exit abnormal Missing output file."。也没找出来是原因。

在本地又单步调试了很久，其中一个可能的原因是，如果预测的时间开始是2015-02-20 00:00:00，结束是2015-02-27 23:59:59。本地算法会将时间计算为0天，因此，再最后进行改进，如果时间为0天，则需要加上一天。但是提交后依然爆出相同的错误。

接下来，从两个方面进行排查。

- 预测的地方出错，先写一个简单的预测算法，看看装箱部分是否出错。
- 装箱的地方出错，使用一个虚拟机分配一个服务器的方法，看看是否是装箱出错。

这样线上调试，真是麻烦，没有本地测试各个函数，感觉很是费劲。。。

经过艰难的调试，用均值预测，加上使用一个虚拟机分配一个服务器的方法,终于测通，还是说明是在装箱的地方出现了问题。

接下来，对昨天写的装箱部分进行调试，看看是什么情况。

## 2018/3/14

昨天，调试到晚上快12点，终于把问题解决了。原因是input文件的服务器内存是以G为单位，而虚拟机是以M为单位，在本地测试时，我看给的服务器内存怎么这么小，就手动改大了点，然后本地测试不会出现什么问题。但是，一提交上去测试就没有比服务器内存小的虚拟机，所以一直运行异常。

这个错误调的很心累，还是审题没看清楚。如果，不是每天有100次的机会，我可能要与本次大赛ByeBye了。最后，一条语句，一条语句的上传，看看是哪里的问题，定位到问题后，又去看了下文档，解决了问题。没有单元测试，可能这就是每天给100次的意义吧。。。

PS：昨天下午5点左右，真是累得不行，总是出错。然后看了一会“神秘巨星”，之后陪女友去逛逛街，又跑去吃了“天一花甲粉”，还是那么好吃。

回去，大概10点，又开始了尝试，近2个小时解决。也是一次很深刻的教训吧。

## 2018/3/17

前两天写了两天的小论文，今天上午又在图书馆复习机器学习。下午终于可以开撸了。

通过研究测评分数发现，预测大值比预测小值会得到更高的分数。

对于devCloud.PredictAllVM()函数而言：

- 原来分数：61.619
- 放大1.2 倍：65.277
- 放大1.5 倍：72.61
- 放大1.9 倍：75.612
- 放大2   倍：77.084
- 放大2.1 倍：75.462
- 放大2.2 倍：75.036
- 放大2.5 倍：71.858

对于devCloud.LastPredictDay()函数而言：

- 原来分数：79.91
- 放大0.9倍：78.554
- 放大1.1倍：83.093
- 放大1.2倍：83.896
- 放大1.3倍：82.822
- 放大1.5倍：76.846
- 放大2.0倍：

发现，对预测的天数的总量加减也会有影响，同对devCloud.LastPredictDay()函数而言，预测结果放大1.2倍。

- 多预测一天：76.726
- 少预测一天：84.397
- 少预测两天：80.207

这就很有意思，通过后处理的组合，会极大的提高分数。但是，这是建立在有个好的算法的基础上进行微调。

## 2018/3/18

想到对于资源优化来讲，其实，如果资源利用率小于一个阈值(比如小于50%)，可以将该服务器再放入适合的同种的虚拟机来提高资源利用率，这样一来资源利用率有所提高，同时，预测大值相同有利，分数应该会有所提升，至于阈值的大小，可以测试到一个合适的比例。

下午实现了一个规则预测，还有很多值得优化的地方。

- 原始分数为：78.899
- 放大1.1 倍：82.512
- 放大1.15倍：85.024
- 放大1.2 倍：86.899
- 放大1.25倍：86.508
- 放大1.5 倍：81.331

## 2018/3/20

实现了BestFit，但是分数并没有提高。

检查了一下利用率，发现确实有一箱的利用率低于50%.

- 原始分数为：78.899
- 用最前面的装最大，提高到82.685，说明有一定的效果
- GuiZe乘以1.2后，在提高，分数反而下降，从86.899下降到86.362，说明一味的提身有风险的。

每个提升一个看看效果：

- 分数反而下降：79.125
- 乘以1.2后，再提高，分数有所提高了：87.104
- 乘以1.2后，对利用率小于70的再提高，分数有所提高了：87.252

## 2018/03/24

用python对给的样本数据进行分析之后，发现并没有明显的可以学习的周期趋势，而且训练样本不太多，使用复杂的模型必定容易过拟合。因此，还是需要在规则的基础上进行改进。

通过观察数据发现，所有虚拟机的当天总量有着明显的波动周期，但是对应每个单独的虚拟机而言，有的有着明显的周期规律，而有的总量比较小，总数在10以下，甚至5以下，基本就没有规则可言。

针对上述的问题，想到对虚拟机根据总量来进行分类，总量大的用规则去学习，而总量小的，可以直接用过去的总量来代替未来的总量。总量的分界值可以依靠线上的效果来确定。

- 暂定方案为该类型的虚拟机如果选择的训练天数n不大于等于n天的总量m，则判定为少量使用类型。
- 反之，如果训练天数n大于等于n天的的总量m，则判定为大量使用类型，至于此类的还需不需要划分，需要再观察。

使用ClassificationPredict()来进行预测，结果居然和GuiZe()的分数一样，但是测试到两种方法都使用了。这就说明对于用的少的样本来讲，使用GuiZe()和使用LastPredictDay()效果相同。

这样，此分类以失败而告终。

尝试一下融合的方案，分类还要继续研究下去。

使用GuiZe()和LastPredictDay()的最好结果进行融合：

- 对上面两种预测的结果各自乘以1.2，再按0.6与0.4加权，分数为85.41
- 对上面两种预测的结果各自乘以1.2，再按0.5与0.5加权，分数为85.297
- 对上面两种预测的结果各自乘以1.2，再按0.65与0.35加权，分数为85.639
- 对上面两种预测的结果各自乘以1.2，再按0.7与0.3加权，分数为85.639

- 对上面两种预测的结果按0.6与0.4加权，分数为77.467
- 对上面两种预测的结果按0.6与0.4加权，再对结果乘以1.2，分数为85.328
- 对上面两种预测的结果按0.5与0.5加权，再对结果乘以1.2，分数为85.232

再次失败，分析可能原因是，此两种方法本质有很大的相似性，并不能够取得异质的效果。

尝试使用SVR的方法进行预测，在网上找了一份开源的代码，链接如下：

[ONLINE SUPPORT VECTOR REGRESSION](http://onlinesvr.altervista.org/)

开始移植。

移植以后：

- 2018-03-24 22:13:54 原版               66.374
- 2018-03-24 22:15:19 乘以1.2以后         73.842

## 2018/03/31

听说换了测评的方法，重新测试一下之前的版本的效果。

- devCloud.SVRPredict() + devCloud.BestFit()， 没有放大预测结果： 相较于上次的66.374 变化到 59.347。减小了近7分。
- devCloud.SVRPredict() + devCloud.BestFit()， 结果放大1.2预测结果： 相较于上次的73.842 变化到 65.956。减小了近8分。
- devCloud.GuiZe() + devCloud.BestFit()，没有放大预测结果：从原来的78.899到71.203，减小7.5分，只按CPU优化，还是71.203。
- devCloud.GuiZe() + devCloud.BestFit()，结果方法1.2倍后，预测结果：从原来的86.899到78.376，减小8.5分。只按CPU优化，分数还为78.376，没有变化，

每次很稳定的减少近8分，很有可能是测评评判方法换了。不知道是不是改进了优化的资源。

刚才浏览了论团，官方也说了换了测评方法。这个，菊厂搞成这个样子还真让人无语啊。官方QQ群里，经常有人放黄图。。。

今天，打算将上周的开源SVR再改进改进，看看有没有提升的空间，如果没有，就抛弃它了，毕竟到时查重还不知道这个开源的代码如何评判。

首先将 Kernel 由 KERNEL_RBF(Radial Basis Function Kernel)换为 KERNEL_RBF_GAUSSIAN (Gaussian RBF Kernel)。这样之后，分数由 65.956 变为70.751。换了一个kernel分数得到了很大的提升。

以下为乘以1.2之后的，各个kernel的分数之间的对比：

- KERNEL_RBF : 65.956
- KERNEL_RBF_GAUSSIAN : 70.751
- KERNEL_RBF_EXPONENTIAL : 64.924
- KERNEL_LINEAR : 47.091
- KERNEL_POLYNOMIAL : 程序发生异常。
- KERNEL_MLP ： 64.924

下面对惩罚参数C进行调参

- C：1      ： 70.751
- C：0.5    ： 69.649
- C：0.8    ： 70.271
- C：1.2    ： 70.556
- C：1.3    ： 70.734
- C：1.5    ： 71.067
- C：2      ： 69.907

接着对epsilon参数调参

- E：0.01   ： 71.067
- E：0.001  ： 71.067
- E：0.1    ： 69.24
- E：0.05   ： 70.953

接着对KernelParam参数调参：

- K：30     : 71.067
- K：10     ： 66.445
- K：20     ：70.679
- K：25     ：71.747
- K：26     ：72.24
- K：27     ：71.095
- K：28     ：71.286
- K：35     ：69.442
- K：40     ：70.293
- K：50     ：70.293
- K：60     ：70.293

至此，SVR最高能做到72.24分，感觉SVR还有很多可以优化的地方，其中有三点需要完成：

- 对异常值的处理
- 对特征归一化
- 重新构造特征空间

目前，最好的参数为：

    OnlineSVR* SVR = new OnlineSVR();
    SVR->SetC(1.5);
    SVR->SetEpsilon(0.01);
    SVR->SetKernelType(OnlineSVR::KERNEL_RBF_GAUSSIAN);
    SVR->SetKernelParam(26);
    SVR->SetVerbosity(OnlineSVR::VERBOSITY_NORMAL);	

下面，尝试一下GuiZe模型和SVR模型融合的效果，毕竟是两种不同的模型。

规则最高分为：78.376 ， SVR最高分为：72.24

- GuiZe 0.5 + SVR 0.5  得分为：74.778
- GuiZe 0.6 + SVR 0.4  得分为：76.995
- GuiZe 0.65 + SVR 0.35  得分为：77.815
- GuiZe 0.7 + SVR 0.3  得分为：78.2
- GuiZe 0.75 + SVR 0.25  得分为：77.92
- GUIZe 0.8 + SVR 0.2  得分为：77.946

SVR的模型效果还很差，融合也没能融合出来好的效果。

### 1 对特征归一化处理

对上周的总量取对数

- 64.493  效果不行

用星期这一个特征能到 69.419，










## 报错总结

- "the number of the placement host is zero. "
- "answer exit abnormal Missing output file."。看说明是因为程序运行中出现异常，运行失败。
- "the number of predicated flavor total number is NOT match with sum of each of predicated flavor in the Output file."
- "the number of predicated flavor total number is NOT match with actual placed flavor number"
- "there are NOT enough resource in the host"